classdef AHP
% The AHP class with contain all the data and methods to generate both...
%  dependent and independent data of an AXON Patch-Clamp file that is...performed by Hal Ketchum
%  generated by running the AHP protocol    
    properties
% This section contains all the properties of the trace file
% A typical Axon binary file (*.abf)
        Filename = '';
        Groupname = '';
        BrainRegion = '';
        ExpDate = NaN; % Format: YYYYMMDD
        BirthDate = NaN; % Format: YYYYMMDD
        TreatEndTime = NaN; % Format: HHMM in 24Hr
        RecStartTime = NaN; % Format: HHMM in 24Hr
        VRest = 0;
        Filepath = '';
        SamplingInterval = 0;
        Channel = '';
        Traces=[];
        HypProbStepSize = -20E-12; % Amplitude of the hyp. current step in pA
        AhpProbStepSize = 25 % Amplitude of the dep. ahp step
    end
% Properties (Constant)
    properties (Constant)
% Information about the AHP protocol is here
% Hyp. pulse 
        HypProbBaseStart = 0.0000; % Start of the baseline for hyp. step. 170 ms duration
        HypProbBaseStop  = 0.17000; % End of the baseline for hyp. step 10 ms before the hyp jump
        HypProbStepStart = 0.17600; % Start of the hyp. current step
        HypProbStepStop = 0.37600; % End of the hyp. current step
        HypProbDisEnd = 0.57622; % End of the discharges from the hyp. pulse
        SeriesResJumpDur = 0.0004 % 0.4 msec
        InputResMaxDur =  0.04 % max hyperpolarozation reached within 70 msec from the hyp. step
% Ahp pulse
        AhpProbBaseStart  = 0.63600; % Start of the baseline for ahp step
        AhpProbBaseStop = 0.64600 % End of the baseline for ahp step
        AhpProbStepStart = 0.6735 % Start of the dep. ahp current step
        AhpProbStepStop  = 1.278 % End of the dep. ahp current step
        AhpProbNSteps = 20; % No. of Ahp current steps
        AhpProbDisEnd = 9 % End of Ahp measurement time
        AhpFindDur = 0.1 % Find the mAHP peak within 100 ms from the end of the Ahp step
        AhpWinM = 0.003; % window for averaging mAhp
        AhpWinS = 0.010; % window for averaging sAhp
        AhpDelayS = 0.325 % Delay for measuring sAhp = 325 ms
        TraceDur = 10;        
    end 
%     properties (Dependent=true)
%         org = struc('VBase',[],'SeriesRes',[],'InputRes',[],'mTau',[],'AhpStep',[],'mAhp',[],'mAhpTime',[],'mAhpLat',[],...
%             'mAhpArea',[],'sAhp',[],'sAhpTime',[],'sAhpLat',[],'sAhpArea',[],'nSpikes',[],'FSThres',[],'FSThresTime',[],...
%             'FSAhp',[],'FSAmp',[],'FSHWidth',[],'FSTime',[],'FSAhpTime',[],'FSLat',[],'Acco',[]);
%     end
% Properties of AHP from the fit
    properties (Dependent = true)
        fit = struc('mAhp_fit',[],'mAhpArea_fit',[],'mAhpTau_fit',[],...
        'sAhp_fit',[],'sAhpArea_fit',[],'sAhpTau_fit',[]);
    end
    properties (SetAccess = private)
        data = struct('t',[],'y',[]);
    end
    methods
% AHP object creator. 
% Input: filename, channelname, no.of traces to load
        function obj = AHP(cellinfo)
            obj.Filename = char(cellinfo.Filename);
            fn_idxstart = max(regexp(obj.Filename,'\/','end'));
            fn_idxend = regexp(obj.Filename,'_C(C|V)\.abf','end');
            obj.Filepath = obj.Filename(1:fn_idxstart);
            obj.Filename = obj.Filename(fn_idxstart+1:fn_idxend-4);
            obj.Groupname = obj.Filename(end-1:end);
            obj.BrainRegion = char(cellinfo.BrainRegion);
            obj.Channel = cellinfo.Channel;
            AllSweeps = 1: obj.AhpProbNSteps;
            obj.Traces = sort(AllSweeps(~ismember(AllSweeps,sort(cellinfo.RemoveTraces))));
            [trc si] = abfload([obj.Filepath, obj.Filename, '.abf'],'channels',{obj.Channel},'sweeps',obj.Traces);
            trc = reshape(trc,size(trc,1),size(trc,3));
            obj.data.y = trc;
            clear trc;
            obj.SamplingInterval=si*1E-06;
            obj.data.t = (0:obj.SamplingInterval:(size(obj.data.y,1)-1)*obj.SamplingInterval)';
             if( (mean(obj.data.y(obj.data.t<0.02)) < -300)); % && strcmpi('10 vm',obj.Channel))
                obj.data.y = obj.data.y/10;
            elseif( (mean(obj.data.y(obj.data.t<0.02)) < -3)) % && strcmpi('10 vm',obj.Channel))
                obj.data.y = obj.data.y*10;
             end
            obj.HypProbStepSize = cellinfo.HypProbStepSize; % Amplitude of the hyp. current step in pA
            obj.AhpProbStepSize = cellinfo.AhpProbStepSize;
            obj.VRest = cellinfo.VRest;
            obj.ExpDate = cellinfo.ExpDate;
            obj.BirthDate = cellinfo.BirthDate;
            obj.TreatEndTime = cellinfo.TreatEndTime;
            obj.RecStartTime = cellinfo.RecStartTime;
        end
        function fit = get.fit(obj)
% Initialize all variables with NaN
            fit.mAhp_fit = NaN(obj.AhpProbNSteps,1);
            fit.mAhpArea_fit = NaN(obj.AhpProbNSteps,1);
            fit.mAhpTau_fit = NaN(obj.AhpProbNSteps,1);
            fit.sAhp_fit = NaN(obj.AhpProbNSteps,1);
            fit.sAhpArea_fit = NaN(obj.AhpProbNSteps,1);
            fit.sAhpTau_fit = NaN(obj.AhpProbNSteps,1);
            obj = ahpfilter(obj,'gauss',50,50/6);
            y = obj.data.y;
            t = obj.data.t;
            dt = t(2)-t(1);
% Get the post-AhpProbStepStop data
            y2 = y(t > obj.AhpProbStepStop & t <= obj.AhpProbDisEnd,:);
% Get the data b/w AhpProbBaseStart & AhpProbBaseStop
            y1 = y(t >= obj.AhpProbBaseStart & t <= obj.AhpProbBaseStop,:);
% Mean of the data b/w AhpProbBaseStart & AhpProbBaseStop
            y1mean = mean(mean(y1,1));
            
% Remove data b/w AhpProbBaseStart & AhpProbBaseStop when more than mean of
% baseline
            y2mean = mean(y2,2);
            pos = find(y2mean <= y1mean,1,'first');
% Stich the baseline with Ahp data
            y3 = [y1;y2(pos:end,:)];
            y3 = bsxfun(@minus,y3,mean(y1,1));
            t3 = [-size(y1,1)*dt:dt:-dt,0:dt:(size(y2(pos:end,:),1)-1)*dt]';

% Set the time axis from start to finish
            
            s.t=t3;
            s.y=y3;
            s = signalfilter(s,'gauss',500,500/8);
            t=s.t;
            y=s.y;
            mAhpy = NaN(1,size(y,2));
            mAhpi = NaN(1,size(y,2));
            mAhpt = NaN(1,size(y,2));
            sAhpy = NaN(1,size(y,2));
            sAhpi = NaN(1,size(y,2));
            sAhpt = NaN(1,size(y,2));
            for i = 1: size(y,2)
                [mAhpy(i),mAhpi(i)] = min(y(t>0 & t < obj.AhpFindDur,i));
                mAhpt(i) = t(mAhpi(i));
                sAhpi(i) = find(t >= (mAhpt(i)+obj.AhpDelayS),1,'first');
                sAhpy(i) = y(sAhpi(i),i);
                sAhpt(i) = t(sAhpi(i));
%                 fprintf('%d %d %d\n',mAhpy(i),mAhpi(i),mAhpt(i));
%                 fprintf('%d %d %d\n',sAhpy(i),sAhpi(i),sAhpt(i));
            end
            fh = @(x,p) p(1) + p(2)*exp(-x./p(3));
            errfh = @(p,x,y) sum((y(:)-fh(x(:),p)).^2);
            options = optimset('Display','on','MaxFunEvals',2000,'MaxIter',2000);
            
            params = NaN(1,size(y,2));
            fitok = NaN(1,size(y,2));
            for i = 1: size(y,2);
                initials = [0, sAhpy(i), 5]; % [offset scale tau]
                fprintf('%d %d %d %d \n',size(t(sAhpi(i):end)),size(y(sAhpi(i):end,i)));
%                 [params(i), ~, fitok(i), ~] = fminsearch(errfh,initials,options,t(sAhpi(i):end),y(sAhpi(i):end,i))
%                 yf = fh(tf,params(i));
%                 plot(y,t); hold on;
%                 plot(tf,yf);
%                 plot(mAhpt(i),mAhpy(i),'ored','Linewidth',2);
%                 plot(sAhpt(i),sAhpy(i),'oblack','Linewidth',2);
%                 pause;
            end
%             plot(t,y); hold on;
%             plot(mAhpt,mAhpy,'ored','Linewidth',2);
%             plot(sAhpt,sAhpy,'oblack','Linewidth',2);
        end
        function org = get.org(obj)
%             obj= ahpfilter(obj,'movingavg',17);
%             close all;
% % Initialize all variables with NaN
%             org.AhpStep = NaN(obj.AhpProbNSteps,1);
%             org.SeriesRes = NaN(obj.AhpProbNSteps,1);
%             org.InputRes = NaN(obj.AhpProbNSteps,1);
%             org.mTau = NaN(obj.AhpProbNSteps,1);
%             org.VBase = NaN(obj.AhpProbNSteps,1);
%             org.mAhp = NaN(obj.AhpProbNSteps,1);
%             org.mAhpTime = NaN(obj.AhpProbNSteps,1);
%             org.mAhpLat = NaN(obj.AhpProbNSteps,1);
%             org.mAhpArea = NaN(obj.AhpProbNSteps,1);
%             org.sAhp = NaN(obj.AhpProbNSteps,1);
%             org.sAhpTime = NaN(obj.AhpProbNSteps,1);
%             org.sAhpLat = NaN(obj.AhpProbNSteps,1);
%             org.sAhpArea = NaN(obj.AhpProbNSteps,1);
%             org.nSpikes = NaN(obj.AhpProbNSteps,1);
%             org.FSThres = NaN(obj.AhpProbNSteps,1);
%             org.FSThresTime = NaN(obj.AhpProbNSteps,1);
%             org.FSAmp = NaN(obj.AhpProbNSteps,1);
%             org.FSHWidth = NaN(obj.AhpProbNSteps,1);
%             org.FSAhp = NaN(obj.AhpProbNSteps,1);            
%             org.FSTime = NaN(obj.AhpProbNSteps,1); 
%             org.FSAhpTime = NaN(obj.AhpProbNSteps,1);   
%             org.FSLat = NaN(obj.AhpProbNSteps,1);   
%             org.Acco = NaN(obj.AhpProbNSteps,1);   
% % Get indices of time vector for passive parameters measurement
%             r1psv  = find(obj.data.time >= (obj.HypProbBaseStop) & obj.data.time <= (obj.HypProbStepStop),1,'first');
%             r2psv  = find(obj.data.time >= (obj.HypProbBaseStop) & obj.data.time <= (obj.HypProbStepStop),1,'last');
% %           r1HypStart  = find(obj.data.time >= (obj.HypProbStepStart) & obj.data.time <= (obj.HypProbStepStop),1,'first'); % activate 4 visualization
% % Get indices of time vector for spike detection
%             r1spk  = find(obj.data.time >= obj.AhpProbStepStart & obj.data.time <= obj.AhpProbStepStop,1,'first');
%             r2spk  = find(obj.data.time >= obj.AhpProbStepStart & obj.data.time <= obj.AhpProbStepStop,1,'last');
% % Loop for each trace in the ahp object measure Series
% % Resistance and input resistance before the gauss filter
%             org.AhpStep = (0: obj.AhpProbNSteps-1)' .* (obj.AhpProbStepSize*1E12);
%             options = optimset('Display','on','MaxFunEvals',2000,'MaxIter',2000);
%             initial_psv = [5E06,150E06, 10E-03]; % [rp rm taum]
%             for i = 1: length(obj.Traces)
%                 atrace = obj.data.response(:,i); 
% % Get one trace at a time from the data structure
% % Calculate Series and Input resistance through curve-fitting
%                 [params, ~, fitok, ~] = fminsearch(@fit_passive_charge,initial_psv,options,obj.data.time(r1psv+7:r2psv),atrace(r1psv+7:r2psv),(obj.HypProbStepStart-obj.HypProbBaseStop),obj.HypProbStepSize);
%                 if (~fitok)
%                     disp('Atchung! passive fit not ok. aborting...');
%                     return;
%                 end
%                 org.SeriesRes(obj.Traces(i)) = params(1) ./ 1E09; % Resistance in Mohms
%                 org.InputRes(obj.Traces(i)) = params(2) ./ 1E09; % Resistance in Mohms (Series+Input resistance!)
%                 org.mTau(obj.Traces(i)) = params(3) *1000;
% % Visual Check for the passive fitting
% %               [tfit yfit] = vp_passive_charge(obj.data.time(2)-obj.data.time(1),obj.data.time(r1psv+7),(obj.HypProbStepStart-obj.HypProbBaseStop),(obj.HypProbStepStop-obj.HypProbStepStart),(atrace(r1HypStart)),obj.HypProbStepSize,params);
% %               close all;
% %               plot(tfit,yfit,'red'); hold on;
% %               plot(obj.data.time(r1psv:r2psv),atrace(r1psv:r2psv),'blue'); 
% %               disp([params(1:2) ./ 1E09, (params(2)-params(1)) ./1E09,params(3)]);
% %               pause;
% % Get spikes info from each trace
%                 [mint,miny,maxt,maxy,acco] = AccoSpikes(obj.data.time(r1spk:r2spk),atrace(r1spk:r2spk),40); %delta voltage  = 40 mV
%                 if (~isempty(maxt) && ~isempty(mint)) % check if there are any spikes detected in a trace
%                     org.nSpikes(obj.Traces(i)) = length(maxt);
%                     org.FSAmp(obj.Traces(i)) = maxy(1);
%                     org.FSAhp(obj.Traces(i)) = miny(1);
%                     org.FSTime(obj.Traces(i)) = maxt(1);
%                     org.FSAhpTime(obj.Traces(i)) = maxt(1); 
%                     org.Acco(obj.Traces(i)) = acco;
%                     org.FSLat(obj.Traces(i)) = (org.FSAhpTime(obj.Traces(i)) - obj.AhpProbStepStart)*1000; % conversion to msec
% % Find first-spike threshold
% % Get indices of time vector from the start of
% % AhpProbStep to the time of first-spike
%                     r1thr  = find(obj.data.time >= (obj.AhpProbStepStart+0.0015) & obj.data.time <= (org.FSTime(obj.Traces(i))-0.0003),1,'first');
%                     r2thr  = find(obj.data.time >= (obj.AhpProbStepStart+0.0015) & obj.data.time <= (org.FSTime(obj.Traces(i))-0.0003),1,'last');
%                     t = obj.data.time(r1thr:r2thr); 
%                     v = atrace(r1thr:r2thr);
%                     [org.FSThresTime(obj.Traces(i)), org.FSThres(obj.Traces(i))] = spikethreshold(t,v./1000,20);% Spike Threshold slope = 20 V/s
%                     org.FSThres(obj.Traces(i)) = org.FSThres(obj.Traces(i))*1000; % Conversion to mV
% % Find first-spike half-width
%                     r1fs = find(obj.data.time>=org.FSThresTime(obj.Traces(i)) & obj.data.time<=org.FSAhpTime(obj.Traces(i)),1,'first'); % Start index of Firstspike from threshold 
%                     r2fs = find(obj.data.time>=org.FSThresTime(obj.Traces(i)) & obj.data.time<=org.FSAhpTime(obj.Traces(i)),1,'last'); % Stop index of Firstspike till FSAhp time
%                     t = obj.data.time(r1fs:r2fs); 
%                     v = atrace(r1fs:r2fs);
% % Find the indexs for v >= Aphalf+spikethreshold
%                     r1hw = find(v>mean([org.FSAhp(obj.Traces(i)),org.FSThres(obj.Traces(i))]),1,'first');
%                     r2hw = find(v>mean([org.FSAhp(obj.Traces(i)),org.FSThres(obj.Traces(i))]),1,'last');
%                     org.FSHWidth(obj.Traces(i)) = (t(r2hw)-t(r1hw))*1000; % conversion to msec
%                     org.FSAhp(obj.Traces(i)) = org.FSAhp(obj.Traces(i))-org.FSThres(obj.Traces(i)); % FSAhp substracted from FSThres
% % END: if                
%                 end
% % END: For loop
%             end
%             obj= ahpfilter(obj,'gauss',1000,1000/6);
%             obj= ahpfilter(obj,'movingavg',11);
% % Get indices of time vector for vbase measurement
%             r1vb  = find(obj.data.time >= obj.HypProbBaseStart & obj.data.time <= obj.HypProbBaseStop,1,'first');
%             r2vb  = find(obj.data.time >= obj.HypProbBaseStart & obj.data.time <= obj.HypProbBaseStop,1,'last');
% % Get indices of time vector for mAhp measurement
%             r1ma  = find(obj.data.time >= obj.AhpProbStepStop & obj.data.time <= (obj.AhpProbStepStop+obj.AhpFindDur),1,'first');
%             r2ma  = find(obj.data.time >= obj.AhpProbStepStop & obj.data.time <= (obj.AhpProbStepStop+obj.AhpFindDur),1,'last');
%             for i = 1: length(obj.Traces)
% % Get one trace at a time from the data structure
%                 atrace = obj.data.response(:,i); 
%                 vbase = mean(atrace(r1vb:r2vb));
%                 org.VBase(obj.Traces(i)) = vbase;
% % Substract baseline
%                 atrace = atrace-vbase; 
%                 [mAhp,r] = min(atrace(r1ma:r2ma));
%                 org.mAhp(obj.Traces(i)) = mAhp;
%                 org.mAhpTime(obj.Traces(i)) = obj.data.time(r+r1ma);
%                 org.mAhpLat(obj.Traces(i)) = (org.mAhpTime(obj.Traces(i))-obj.AhpProbStepStop)*1000; % Conversion to msec
% % Get time indices of mAHP window to average
%                 r1wma  = find(obj.data.time >= (org.mAhpTime(obj.Traces(i)) - obj.AhpWinM) & obj.data.time <= (org.mAhpTime(obj.Traces(i)) + obj.AhpWinM),1,'first');
%                 r2wma  = find(obj.data.time >= (org.mAhpTime(obj.Traces(i)) - obj.AhpWinM) & obj.data.time <= (org.mAhpTime(obj.Traces(i)) + obj.AhpWinM),1,'last');
%                 org.mAhp(obj.Traces(i))=mean(atrace(r1wma:r2wma));
% % Get time indices of sAHP window to average
%                 r1wsa  = find(obj.data.time >= (org.mAhpTime(obj.Traces(i)) +obj.AhpDelayS-obj.AhpWinS) & obj.data.time <= (org.mAhpTime(obj.Traces(i)) +obj.AhpDelayS+obj.AhpWinS),1,'first');
%                 r2wsa  = find(obj.data.time >= (org.mAhpTime(obj.Traces(i)) +obj.AhpDelayS-obj.AhpWinS) & obj.data.time <= (org.mAhpTime(obj.Traces(i)) +obj.AhpDelayS+obj.AhpWinS),1,'last');
%                 org.sAhp(obj.Traces(i))=mean(atrace(r1wsa:r2wsa));
%                 org.sAhpTime(obj.Traces(i)) = mean(obj.data.time(r1wsa:r2wsa));
%                 org.sAhpLat(obj.Traces(i))  = (org.sAhpTime(obj.Traces(i))-obj.AhpProbStepStop)*1000; % Conversion to msec
% % mAhp area time: End of AhpProbStep to sAhp time
%                 r1maa  = find(obj.data.time >= obj.AhpProbStepStop & obj.data.time <= org.sAhpTime(obj.Traces(i)),1,'first');
%                 r2maa  = find(obj.data.time >= obj.AhpProbStepStop & obj.data.time <= org.sAhpTime(obj.Traces(i)),1,'last');
%                 org.mAhpArea(obj.Traces(i))=trapz(obj.data.time(r1maa:r2maa),atrace(r1maa:r2maa));
% % sAhp area time: sAhp time to AhpProbDisEnd
%                 r1saa  = find(obj.data.time >= org.sAhpTime(obj.Traces(i)) & obj.data.time <= obj.AhpProbDisEnd,1,'first');
%                 r2saa  = find(obj.data.time >= org.sAhpTime(obj.Traces(i)) & obj.data.time <= obj.AhpProbDisEnd,1,'last');
%                 org.sAhpArea(obj.Traces(i))=trapz(obj.data.time(r1saa:r2saa),atrace(r1saa:r2saa));
% % END: for loop            
             end          
        function [tthr,spkthr] = spikethreshold(t,v,threshold)
%                 if (nargin ==2)
%                     threshold = 20;
%                     disp('Threshold calculated from dv/dt = 20, units: V/sec or mv/ms');
%                 end
%                 [tx, vx, vd] = diffspike(t,v,4); % a step size of 4 choose to reduce noise
%                 norm = mean(vd(~isnan(vd)));
%                 vd = vd-norm;
% %               plot(vx,vd); hold on; pause;
%                 ithr_vd = find(vd < threshold,1,'last'); % index of threshold from dv
%                 spkthr = vx(ithr_vd);
%                 tthr = tx(ithr_vd);
% %               disp([tthr,spkthr]);
% % END: function [tthr,spkthr] = spikethreshold(t,v,threshold)
             end            
% % Function computed the phase space of an action potential
% % Numerical derivative with a step size
        function [tx,vx,vd] = diffspike(t,v,step) 
%                 if (nargin <=2)
%                     step=1;
%                 end
%                 if (rem(step,2) ~= 0)
%                     step = step+1;
%                     disp(['Step has to be even! Step is now:',num2str(step)]);
%                 end
%                 tx = NaN(floor(length(t)/step),1);
%                 vx = NaN(floor(length(t)/step),1);
%                 vd = NaN(floor(length(t)/step),1);
%                 j=0;
%                 for k = step+1:step: length(t)
%                     j = j+1;
%                     vd(j) = (v(k)-v(k-step)) / (t(k)-t(k-step));
%                     vx(j) = mean(v((k-step):k));
%                     tx(j) = mean(t((k-step):k));
%                end
% % END: function [tx,vx,vd] = diffspike(t,v,step) 
        end        
        function [mint, miny, maxt, maxy, acco] = AccoSpikes(t,y,delta)
%                 mint = nan(100);
%                 miny = nan(100);
%                 maxt = nan(100);
%                 maxy = nan(100);
%                 minval = +Inf; minpos = 0;
%                 maxval = -Inf; maxpos = 0;
%                 look4max=1;
%                 maxcnt=0; mincnt=0;
%                 for j = 1: length(y)-1
%                     if(y(j) > maxval) 
%                         maxval = y(j); 
%                         maxpos = t(j); 
%                     end
%                     if(y(j) < minval)
%                         minval = y(j);
%                         minpos = t(j);
%                     end
%                     if(look4max)
%                         if(y(j) < maxval-delta) 
%                             maxcnt = maxcnt+1;
%                             maxy(maxcnt)=maxval; 
%                             maxt(maxcnt)=maxpos;
%                             minval = y(j); 
%                             minpos = t(j);
%                             look4max=0;
%                         end
%                     else
%                         if(y(j) > minval+delta) 
%                             mincnt= mincnt+1;
%                             miny(mincnt)=minval; 
%                             mint(mincnt)=minpos;
%                             maxval = y(j); 
%                             maxpos = t(j);
%                             look4max=1;
%                         end
%                     end
%                 end
%                 maxt = maxt(1:maxcnt);
%                 maxy = maxy(1:maxcnt);
%                 if (sum(~isnan(maxy))>=1)
%                     mincnt=mincnt+1;
%                     miny(mincnt)=minval; 
%                     mint(mincnt)=minpos;
%                 end
%                 mint = mint(1: mincnt);
%                 miny = miny(1:mincnt);
% % Find the accomodation
%                 if (length(maxt)<2)
% % Accomodation not computed if fewer than 2 spikes
%                     acco=NaN;
%                 elseif (length(maxt)==2) 
% % If no.of spiked = 2 
%                     acco = (maxt(2)-maxt(1))/(maxt(1)-t(1));
%                 elseif (length(maxt)>2) % 
%                     acco = (maxt(end)-maxt(end-1))/(maxt(2)-maxt(1));
% % END: if elseif
%                 end
% % END:function [mint, miny, maxt, maxy, acco] = AccoSpikes(t,y,delta)         
        end
        function ahpout = ahpfilter(ahpin,type,length,sigma)
            ahpout=ahpin;
            if (nargin<4) && strcmp(type,'gauss')
                message('Not enough parameters for Gaussian filter!')
                abort;
            end
            x = linspace(-length/2,length/2,length);
            if strcmp(type,'movingavg')
                coeff = ones(length);
            elseif strcmp(type,'gauss')
                coeff = 1/sqrt((2*pi)*sigma)*exp(- x .^ 2 / (2 * sigma ^ 2));
            end
            coeff = coeff / sum (coeff); % normalize filter coefficients
            for k = 1: size(ahpout.data.y,2)
                ahpout.data.y(:,k) = conv(ahpout.data.y(:,k), coeff, 'same');  
% no delay by using convolution
            end
% less of (len/2-1) points from front & len/2 point from rear
            ahpout.data.t = ahpout.data.t(ceil(length/2): end-(ceil(length/2)),:);  
% same as above; total reduction of points  = (len-1) points
            ahpout.data.y = ahpout.data.y(ceil(length/2): end-(ceil(length/2)),:); 
% END METHOD: ahpout = ahpfilter(ahpin,type,length,sigma)
        end
        function plotahpobj(obj)
%             obj= ahpfilter(obj,'movingavg',25);
%             obj= ahpfilter(obj,'gauss',1000,1000/6);
%             obj= ahpfilter(obj,'movingavg',11);
%             close all;
%             org = obj.org;
%             for i = 1:length(obj.Traces)
%                 atrace = obj.data.response(:,i);
%                 plot(obj.data.time,atrace);
%                 hold on;
%                 plot(org.mAhpTime(obj.Traces(i)),org.mAhp(obj.Traces(i))+org.VBase(obj.Traces(i)),'sk','markersize',6,'markerfacecolor','r');
%                 plot(org.sAhpTime(obj.Traces(i)),org.sAhp(obj.Traces(i))+org.VBase(obj.Traces(i)),'sk','markersize',6,'markerfacecolor','r');
%             end
%             axis([obj.AhpProbStepStart,max(org.sAhpTime),min(org.mAhp),1]);
%             title([obj.Filename],'Interpreter','none');
%             xlabel('Time (sec)','FontSize',16);
%             ylabel('Voltage (mV)','FontSize',16);
% % END Function: plotahpobj(obj)
        end      
    end
end
