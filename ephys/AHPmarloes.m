classdef AHPmarloes
% The AHP class with contain all the data and methods to generate both
% dependent and independent data of an AXON Patch-Clamp file that is
% generated by running the AHP protocol run by Marloes    
    properties
        % Properties of protocol 1: IV
        IV = cell2struct({'','','',0,0,0,0,0,0,0,0,0,0,[]},{'Filename','Path','Channel','SI','nSweeps','BaseStart','BaseStop',...
        'BaseAmp','StepStart','StepStop','StepAmp','StepDelta','SweepStop','Sweeps'},2);
        sResFindDur = 0.0004; % 0.4 msec
        iResFindDur =  0.04; % max hyperpolarozation reached within 70 msec from the hyp. step
        % Properties of protocol 2: sAhp or fAhp
        Ahp = cell2struct({'','','',0,0,0,0,0,0,0,0,0,0,[]},{'Filename','Path','Channel','SA','nSweeps','Basestart','Basestop',...
        'BaseAmp','StepStart','StepStop','StepAmp','StepDelta','SweepStop','Sweeps'},2);
        AhpFindDur = 0.1; % Find the mAHP peak within 100 ms from the end of the Ahp step
        mAhpWin = 0.003; % window for averaging mAhp
        sAhpWin = 0.010; % window for averaging sAhp
        sAhpDelay = 0.325 % Delay for measuring sAhp = 325 ms 
%     end
    end
    properties (SetAccess = private)
       dataIV = struct('time',[],'volts',[]);
       dataAhp = struct('time',[],'volts',[]);
    end
    properties (Dependent=true)
        org = struc('Vmem',[],'AhpStep',[],'mAhp',[],'mAhpTime',[],'mAhpLat',[],'mAhpArea',[],'sAhp',[],...
            'sAhpTime',[],'sAhpLat',[],'sAhpArea',[],'nSpikes',[],'FSThres',[],'FSThresTime',[],'FSAhp',[],'FSAmp',[],...
            'FSHWidth',[],'FSTime',[],'FSAhpTime',[],'FSLat',[],'Acco',[]);
        IVpsv = struc('Vmem',[],'Step',[],'SeriesRes',[],'InputRes',[],'mTau',[]);
    end
    methods
%     AHP object creator. 
%     Input: two structures each for IV and Ahp protocols
        function obj = AHPmarloes(IV,Ahp)
            %-------------------- IV ----------------------------
            fname  = char(IV.FileName);
            idx_backslash = (regexp(fname,'\/','end'));
            idx_dotabf = regexp(fname,'.abf','start'); 
%             obj.IV.Filename = [fname(idx_backslash(end-1)+1:idx_backslash(end)-1),fname(idx_backslash(end)+1:idx_dotabf-1)];
            obj.IV.Filename = fname(idx_backslash(end)+1:idx_dotabf-1);% just the tarcefilename
            obj.IV.Path = fname(1:idx_backslash(end));
            obj.IV.Channel = char(IV.Channel);
            obj.IV.nSweeps = sort(IV.nSweeps);
            obj.IV.BaseStart = IV.BaseStart;
            obj.IV.BaseStop = IV.BaseStop;
            obj.IV.BaseAmp = IV.BaseAmp*1E-09;
            obj.IV.StepStart = IV.StepStart;
            obj.IV.StepStop = IV.StepStop;
            obj.IV.StepAmp = IV.StepAmp*1E-09;
            obj.IV.StepDelta = IV.StepDelta*1E-09;
            obj.IV.SweepStop = IV.SweepStop;
            AllSweeps = 1:IV.nSweeps;
            obj.IV.Sweeps = AllSweeps(~ismember(AllSweeps,[IV.NoTraces]));
            [trc, obj.IV.SI] = abfload([obj.IV.Path, obj.IV.Filename,'.abf'],'channels',{obj.IV.Channel},'sweeps',obj.IV.Sweeps);
            trc = reshape(trc,size(trc,1),size(trc,3));
            obj.IV.SI = obj.IV.SI*1E-06;
            obj.dataIV.volts = trc;
            obj.dataIV.time = (0:obj.IV.SI:(size(obj.dataIV.volts,1)-1)*obj.IV.SI)';
            % ---------------- Ahp -------------------------
            fname  = char(Ahp.FileName);
            idx_backslash = (regexp(fname,'\/','end'));
            idx_dotabf = regexp(fname,'.abf','start');
%             obj.Ahp.Filename = [fname(idx_backslash(end-1)+1:idx_backslash(end)-1),fname(idx_backslash(end)+1:idx_dotabf-1)];
            obj.Ahp.Filename = fname(idx_backslash(end)+1:idx_dotabf-1);% just the tarcefilename
            obj.Ahp.Path = fname(1:idx_backslash(end));
            obj.Ahp.Channel = char(Ahp.Channel);
            obj.Ahp.nSweeps = sort(Ahp.nSweeps);
            obj.Ahp.BaseStart = Ahp.BaseStart;
            obj.Ahp.BaseStop = Ahp.BaseStop;
            obj.Ahp.BaseAmp = Ahp.BaseAmp*1E-09;
            obj.Ahp.StepStart = Ahp.StepStart;
            obj.Ahp.StepStop = Ahp.StepStop;
            obj.Ahp.StepAmp = Ahp.StepAmp*1E-09;
            obj.Ahp.StepDelta = Ahp.StepDelta*1E-09;
            obj.Ahp.SweepStop = Ahp.SweepStop;
            AllSweeps = 1:Ahp.nSweeps;
            obj.Ahp.Sweeps = AllSweeps(~ismember(AllSweeps,[Ahp.NoTraces]));
            obj.Ahp.Sweeps = AllSweeps(~ismember(AllSweeps,[Ahp.NoTraces]));
            [trc, obj.Ahp.SI] = abfload([obj.Ahp.Path, obj.Ahp.Filename,'.abf'],'channels',{obj.Ahp.Channel},'sweeps',obj.Ahp.Sweeps);
            trc = reshape(trc,size(trc,1),size(trc,3));
            obj.Ahp.SI = obj.Ahp.SI*1E-06;
            obj.dataAhp.volts = trc;
            obj.dataAhp.time = (0:obj.Ahp.SI:(size(obj.dataAhp.volts,1)-1)*obj.Ahp.SI)';
        end
        function IVpsv = get.IVpsv(obj)
            obj= ahpfilter(obj,'movingavg',17);
            IVpsv.Vmem = NaN(obj.IV.nSweeps,1);
            IVpsv.Step = NaN(obj.IV.nSweeps,1);
            IVpsv.SeriesRes = NaN(obj.IV.nSweeps,1);
            IVpsv.InputRes = NaN(obj.IV.nSweeps,1);
            IVpsv.mTau = NaN(obj.IV.nSweeps,1);
            % Get indices of time vector for passive parameters measurement
            r1IV  = find(obj.dataIV.time >= (obj.IV.BaseStop-0.01) & obj.dataIV.time <= (obj.IV.StepStop-0.005),1,'first');
            r2IV  = find(obj.dataIV.time >= (obj.IV.BaseStop-0.01) & obj.dataIV.time <= (obj.IV.StepStop-0.005),1,'last');
%             r1Step = find(obj.dataIV.time >= (obj.IV.StepStart) & obj.dataIV.time <= (obj.IV.StepStop),1,'first'); % activate 4 visualization
            % Loop for each trace in the ahp object measure Series and Input resistance
            % resistance and input resistance before the gauss filter
            options = optimset('Display','on','MaxFunEvals',3000,'MaxIter',3000);
            initial_psv = [10E06,10E06, 2E-03]; % [rp rm taum]
            for i = 1: length(obj.IV.Sweeps)
                IVstep = (obj.IV.StepAmp-obj.IV.BaseAmp)+obj.IV.StepDelta*(i-1);
                if (IVstep >= 0)
                    disp('Exiting for +ve depolarization steps');
                    break;
                end
                IVpsv.Step(i) = IVstep*1E12;
                atrace= obj.dataIV.volts(:,i); % Get one trace at a time from the data structure
                % Calculate Series and Input resistance through
                % curve-fitting
                [params, ~, fitok, ~] = fminsearch(@fit_passive_charge,initial_psv,options,obj.dataIV.time(r1IV+5:r2IV),atrace(r1IV+7:r2IV),(obj.IV.StepStart-obj.IV.BaseStop+0.01),IVstep);
                if (~fitok)
                    disp('Atchung! passive fit not ok. aborting...');
                    return;
                end
                IVpsv.SeriesRes(obj.IV.Sweeps(i)) = params(1) ./ 1E09; % Resistance in Mohms
                IVpsv.InputRes(obj.IV.Sweeps(i)) = params(2) ./ 1E09; % Resistance in Mohms (Series+Input resistance!)
                IVpsv.InputRes(obj.IV.Sweeps(i)) = IVpsv.InputRes(obj.IV.Sweeps(i))-IVpsv.SeriesRes(obj.IV.Sweeps(i));
                IVpsv.mTau(obj.IV.Sweeps(i)) = params(3) *1000;
%                 Visual Check for the passive fitting
%                 [tfit yfit] = vp_passive_charge(obj.IV.SI,obj.dataIV.time(r1IV),...
%                                 (obj.IV.StepStart-obj.IV.BaseStop+0.01),(obj.IV.StepStop-obj.IV.StepStart),...
%                                 (atrace(r1IV)), IVstep,params);
%                 close all;
%                 plot(tfit,yfit,'red'); hold on;
%                 plot(obj.dataIV.time(r1IV:r2IV),atrace(r1IV:r2IV),'blue'); 
%                 disp([params(1:2) ./ 1E09, (params(2)-params(1)) ./1E09,params(3)]);
%                 pause; 
            end
        end        
        function org = get.org(obj)
            obj= ahpfilter(obj,'movingavg',17);
            % Initialize all variables with NaN
            org.AhpStep = NaN(obj.Ahp.nSweeps,1);
            org.Vmem = NaN(obj.Ahp.nSweeps,1);
            org.mAhp = NaN(obj.Ahp.nSweeps,1);
            org.mAhpTime = NaN(obj.Ahp.nSweeps,1);
            org.mAhpLat = NaN(obj.Ahp.nSweeps,1);
            org.mAhpArea = NaN(obj.Ahp.nSweeps,1);
            org.sAhp = NaN(obj.Ahp.nSweeps,1);
            org.sAhpTime = NaN(obj.Ahp.nSweeps,1);
            org.sAhpLat = NaN(obj.Ahp.nSweeps,1);
            org.sAhpArea = NaN(obj.Ahp.nSweeps,1);
            org.nSpikes = NaN(obj.Ahp.nSweeps,1);
            org.FSThres = NaN(obj.Ahp.nSweeps,1);
            org.FSThresTime = NaN(obj.Ahp.nSweeps,1);
            org.FSAmp = NaN(obj.Ahp.nSweeps,1);
            org.FSHWidth = NaN(obj.Ahp.nSweeps,1);
            org.FSAhp = NaN(obj.Ahp.nSweeps,1);            
            org.FSTime = NaN(obj.Ahp.nSweeps,1); 
            org.FSAhpTime = NaN(obj.Ahp.nSweeps,1);   
            org.FSLat = NaN(obj.Ahp.nSweeps,1);   
            org.Acco = NaN(obj.Ahp.nSweeps,1);   
            %--------------------------------------------------
            % Get indices of time vector for spike detection
             r1spk  = find(obj.dataAhp.time >= obj.Ahp.StepStart & obj.dataAhp.time <= obj.Ahp.StepStop,1,'first');
             r2spk  = find(obj.dataAhp.time >= obj.Ahp.StepStart & obj.dataAhp.time <= obj.Ahp.StepStop,1,'last');
             for i = 1: length(obj.Ahp.Sweeps)
                atrace= obj.dataAhp.volts(:,i); % Get one trace at a time from the data structure
                [mint,miny,maxt,maxy, acco] = AccoSpikes(obj.dataAhp.time(r1spk:r2spk),atrace(r1spk:r2spk),40,0.05); %delta voltage  = 40 mV
                if (~isempty(maxt) && ~isempty(mint)) % check if there are any spikes detected in a trace
                    org.nSpikes(obj.Ahp.Sweeps(i)) = length(maxt);
                    org.Acco(obj.Ahp.Sweeps(i)) = acco;
                    org.FSAmp(obj.Ahp.Sweeps(i)) = maxy(1);
                    org.FSAhp(obj.Ahp.Sweeps(i)) = miny(1);
                    org.FSTime(obj.Ahp.Sweeps(i)) = maxt(1);
                    org.FSAhpTime(obj.Ahp.Sweeps(i)) = maxt(1); 
                    org.FSLat(obj.Ahp.Sweeps(i)) = (org.FSAhpTime(obj.Ahp.Sweeps(i)) - obj.Ahp.StepStart)*1000; % conversion to msec
                    % Find first-spike threshold
                    % Get indices of time vector from the start of
                    % AhpProbStep to the time of first-spike
                    r1thr  = find(obj.dataAhp.time >= (obj.Ahp.StepStart+0.0015) & obj.dataAhp.time <= (org.FSTime(obj.Ahp.Sweeps(i))-0.0003),1,'first');
                    r2thr  = find(obj.dataAhp.time >= (obj.Ahp.StepStart+0.0015) & obj.dataAhp.time <= (org.FSTime(obj.Ahp.Sweeps(i))-0.0003),1,'last');
                    t = obj.dataAhp.time(r1thr:r2thr); 
                    v = atrace(r1thr:r2thr);
                    [org.FSThresTime(obj.Ahp.Sweeps(i)), org.FSThres(obj.Ahp.Sweeps(i))] = spikethreshold(t,v./1000,20);
                    org.FSThres(obj.Ahp.Sweeps(i)) = org.FSThres(obj.Ahp.Sweeps(i))*1000; % Conversion to mV
                   % Find first-spike half-width
                    r1fs = find(obj.dataAhp.time>=org.FSThresTime(obj.Ahp.Sweeps(i)) & obj.dataAhp.time<=org.FSAhpTime(obj.Ahp.Sweeps(i)),1,'first'); % Start index of Firstspike from threshold 
                    r2fs = find(obj.dataAhp.time>=org.FSThresTime(obj.Ahp.Sweeps(i)) & obj.dataAhp.time<=org.FSAhpTime(obj.Ahp.Sweeps(i)),1,'last'); % Stop index of Firstspike till FSAhp time
                    t = obj.dataAhp.time(r1fs:r2fs); 
                    v = atrace(r1fs:r2fs);
                    % Find the indexs for v >= Aphalf+spikethreshold
                    r1hw = find(v>mean([org.FSAhp(obj.Ahp.Sweeps(i)),org.FSThres(obj.Ahp.Sweeps(i))]),1,'first');
                    r2hw = find(v>mean([org.FSAhp(obj.Ahp.Sweeps(i)),org.FSThres(obj.Ahp.Sweeps(i))]),1,'last');
                    org.FSHWidth(obj.Ahp.Sweeps(i)) = (t(r2hw)-t(r1hw))*1000; % conversion to msec
                    org.FSAhp(obj.Ahp.Sweeps(i)) = org.FSAhp(obj.Ahp.Sweeps(i))-org.FSThres(obj.Ahp.Sweeps(i)); % FSAhp substracted from FSThres
                end
             end % End for loop: -----------------------------------------------------Spike measurements
            obj= ahpfilter(obj,'gauss',1000,1000/6);
            obj= ahpfilter(obj,'movingavg',11);
            % Get indices of time vector for vbase measurement
            r1vb  = find(obj.dataAhp.time >= obj.Ahp.BaseStart & obj.dataAhp.time <= obj.Ahp.BaseStop,1,'first');
            r2vb  = find(obj.dataAhp.time >= obj.Ahp.BaseStart & obj.dataAhp.time <= obj.Ahp.BaseStop,1,'last');
            % Get indices of time vector for mAhp measurement
            r1ma  = find(obj.dataAhp.time >= obj.Ahp.StepStop & obj.dataAhp.time <= (obj.Ahp.StepStop+obj.AhpFindDur),1,'first');
            r2ma  = find(obj.dataAhp.time >= obj.Ahp.StepStop & obj.dataAhp.time <= (obj.Ahp.StepStop+obj.AhpFindDur),1,'last');
            for i = 1: length(obj.Ahp.Sweeps)
                org.AhpStep(obj.Ahp.Sweeps(i)) = ((obj.Ahp.StepAmp-obj.Ahp.BaseAmp)+obj.Ahp.StepDelta*(i-1) )*1E12;
                atrace = obj.dataAhp.volts(:,i); % Get one trace at a time from the data structure
                vbase = mean(atrace(r1vb:r2vb));
                org.Vmem(obj.Ahp.Sweeps(i)) = vbase;
                atrace = atrace-vbase; % Substract baseline
                [mAhp,r] = min(atrace(r1ma:r2ma));
                org.mAhp(obj.Ahp.Sweeps(i)) = mAhp;
                org.mAhpTime(obj.Ahp.Sweeps(i)) = obj.dataAhp.time(r+r1ma);
                org.mAhpLat(obj.Ahp.Sweeps(i)) = (org.mAhpTime(obj.Ahp.Sweeps(i))-obj.Ahp.StepStop)*1000; % Conversion to msec
                % Get time indices of mAHP window to average
                r1wma  = find(obj.dataAhp.time >= (org.mAhpTime(obj.Ahp.Sweeps(i)) - obj.mAhpWin) & obj.dataAhp.time <= (org.mAhpTime(obj.Ahp.Sweeps(i)) + obj.mAhpWin),1,'first');
                r2wma  = find(obj.dataAhp.time >= (org.mAhpTime(obj.Ahp.Sweeps(i)) - obj.mAhpWin) & obj.dataAhp.time <= (org.mAhpTime(obj.Ahp.Sweeps(i)) + obj.mAhpWin),1,'last');
                org.mAhp(obj.Ahp.Sweeps(i))=mean(atrace(r1wma:r2wma));
                % Get time indices of sAHP window to average
                r1wsa  = find(obj.dataAhp.time >= (org.mAhpTime(obj.Ahp.Sweeps(i)) +obj.sAhpDelay-obj.sAhpWin) & obj.dataAhp.time <= (org.mAhpTime(obj.Ahp.Sweeps(i)) +obj.sAhpDelay+obj.sAhpWin),1,'first');
                r2wsa  = find(obj.dataAhp.time >= (org.mAhpTime(obj.Ahp.Sweeps(i)) +obj.sAhpDelay-obj.sAhpWin) & obj.dataAhp.time <= (org.mAhpTime(obj.Ahp.Sweeps(i)) +obj.sAhpDelay+obj.sAhpWin),1,'last');
                org.sAhp(obj.Ahp.Sweeps(i))=mean(atrace(r1wsa:r2wsa));
                org.sAhpTime(obj.Ahp.Sweeps(i)) = mean(obj.dataAhp.time(r1wsa:r2wsa));
                org.sAhpLat(obj.Ahp.Sweeps(i))  = (org.sAhpTime(obj.Ahp.Sweeps(i))-obj.Ahp.StepStop)*1000; % Conversion to msec
                % mAhp area time: End of AhpProbStep to sAhp time
                r1maa  = find(obj.dataAhp.time >= obj.Ahp.StepStop & obj.dataAhp.time <= org.sAhpTime(obj.Ahp.Sweeps(i)),1,'first');
                r2maa  = find(obj.dataAhp.time >= obj.Ahp.StepStop & obj.dataAhp.time <= org.sAhpTime(obj.Ahp.Sweeps(i)),1,'last');
                org.mAhpArea(obj.Ahp.Sweeps(i))=trapz(obj.dataAhp.time(r1maa:r2maa),atrace(r1maa:r2maa));
                % sAhp area time: sAhp time to AhpProbDisEnd
                r1saa  = find(obj.dataAhp.time >= org.sAhpTime(obj.Ahp.Sweeps(i)) & obj.dataAhp.time <= obj.Ahp.SweepStop,1,'first');
                r2saa  = find(obj.dataAhp.time >= org.sAhpTime(obj.Ahp.Sweeps(i)) & obj.dataAhp.time <= obj.Ahp.SweepStop,1,'last');
                org.sAhpArea(obj.Ahp.Sweeps(i))=trapz(obj.dataAhp.time(r1saa:r2saa),atrace(r1saa:r2saa));
            end
            function [tthr,spkthr] = spikethreshold(t,v,threshold)
            if (nargin ==2)
                threshold = 20;
                disp('Threshold calculated from dv/dt = 20, units: V/sec or mv/ms');
            end
            [tx, vx, vd] = diffspike(t,v,4); % a step size of 4 choose to reduce noise
            norm = mean(vd(~isnan(vd)));
            vd = vd-norm;
%             plot(vx,vd); hold on; pause;
            ithr_vd = find(vd < threshold,1,'last'); % index of threshold from dv
            spkthr = vx(ithr_vd);
            tthr = tx(ithr_vd);
%             disp([tthr,spkthr]);
            end  % Func: phase space of an action potential
            function [tx,vx,vd] = diffspike(t,v,step) % Func: Numerical derivative with a step size
            if (nargin <=2)
                step=1;
            end
            if (rem(step,2) ~= 0)
                step = step+1;
                disp(['Step has to be even! Step is now:',num2str(step)]);
            end
            tx = NaN(floor(length(t)/step),1);
            vx = NaN(floor(length(t)/step),1);
            vd = NaN(floor(length(t)/step),1);
            j=0;
            for k = step+1:step: length(t)
                j = j+1;
                vd(j) = (v(k)-v(k-step)) / (t(k)-t(k-step));
                vx(j) = mean(v((k-step):k));
                tx(j) = mean(t((k-step):k));
            end
            end 
            function [mint, miny, maxt, maxy, varargout] = AccoSpikes(t,y,delta,varargin)
                mint = nan(100);
                miny = nan(100);
                maxt = nan(100);
                maxy = nan(100);
                minval = +Inf; minpos = 0;
                maxval = -Inf; maxpos = 0;
                look4max=1;
                maxcnt=0; mincnt=0;
                for j = 1: length(y)-1
                    if(y(j) > maxval) 
                        maxval = y(j); 
                        maxpos = t(j); 
                    end
                    if(y(j) < minval)
                        minval = y(j);
                        minpos = t(j);
                    end
                    if(look4max)
                        if(y(j) < maxval-delta) 
                            maxcnt = maxcnt+1;
                            maxy(maxcnt)=maxval; 
                            maxt(maxcnt)=maxpos;
                            minval = y(j); 
                            minpos = t(j);
                            look4max=0;
                        end
                    else
                        if(y(j) > minval+delta) 
                            mincnt= mincnt+1;
                            miny(mincnt)=minval; 
                            mint(mincnt)=minpos;
                            maxval = y(j); 
                            maxpos = t(j);
                            look4max=1;
                        end
                    end
                end
            maxt = maxt(1:maxcnt);
            maxy = maxy(1:maxcnt);
            if (sum(~isnan(maxy))>=1)
                mincnt=mincnt+1;
                miny(mincnt)=minval; 
                mint(mincnt)=minpos;
            end
        mint = mint(1: mincnt);
        miny = miny(1:mincnt);
        % Find the accomodation
        close all;
        if (nargin >3)
            accofind = varargin{1};
            earlyspikes = sum((maxt-t(1))<=accofind);
            latespikes = sum((maxt-t(end)+0.001)>=-accofind); % added 0.001 ms to adjust the missing if late spikes
%             plot(t,y); hold on;
%             plot(maxt,maxy,'or');
%             plot([t(1)+accofind,t(1)+accofind],ylim,'r');
%             plot([t(end)-accofind,t(end)-accofind],ylim,'r');
%             disp([earlyspikes,latespikes]);
%             pause;
            varargout{1} = earlyspikes/latespikes;
        end
    end
        end % End get.org
        function ahpout = ahpfilter(ahpin,type,length,sigma)
            ahpout=ahpin;
            if (nargin<4) && strcmp(type,'gauss')
                message('Not enough parameters for Gaussian filter!')
                abort;
            end
            x = linspace(-length/2,length/2,length);
            if strcmp(type,'movingavg')
                coeff = ones(length);
            elseif strcmp(type,'gauss')
                coeff = 1/sqrt((2*pi)*sigma)*exp(- x .^ 2 / (2 * sigma ^ 2));
            end
            coeff = coeff / sum (coeff); % normalize filter coefficients
            for k = 1: size(ahpout.dataIV.volts,2)
                ahpout.dataIV.volts(:,k) = conv(ahpout.dataIV.volts(:,k), coeff, 'same');  % no delay by using convolution
            end
            ahpout.dataIV.time = ahpout.dataIV.time(ceil(length/2): end-(ceil(length/2)),:);  % less of (len/2-1) points from front & len/2 point from rear 
            ahpout.dataIV.volts = ahpout.dataIV.volts(ceil(length/2): end-(ceil(length/2)),:); % same as above; total reduction of points  = (len-1) points
            for k = 1: size(ahpout.dataAhp.volts,2)
                ahpout.dataAhp.volts(:,k) = conv(ahpout.dataAhp.volts(:,k), coeff, 'same');  % no delay by using convolution
            end
            ahpout.dataAhp.time = ahpout.dataAhp.time(ceil(length/2): end-(ceil(length/2)),:);  % less of (len/2-1) points from front & len/2 point from rear 
            ahpout.dataAhp.volts = ahpout.dataAhp.volts(ceil(length/2): end-(ceil(length/2)),:); % same as above; total reduction of points  = (len-1) points
        end % Func: objfilter
    end % Methods:
end